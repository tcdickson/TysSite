[
  {
    "objectID": "DesignDocument.html",
    "href": "DesignDocument.html",
    "title": "Design Document",
    "section": "",
    "text": "The user should be able to enter and remove job details, job offers, adjust comparison settings, and compare jobs\nData that has been entered into the system is persisted, and is loaded after the application is opened back up.\nThe user will have sufficient hardware capabilities to handle the application’s performance requirements.\nAndroid Room provides a reliable method for the user to store data.\nStandard security practices will adequately protect user data from unauthorized access.\n\n\n\n\n\n\n\n\nThe application targets Android 13, introducing behavior changes and new APIs that may affect user experience. To ensure broad compatibility, testing across devices running Android 12 through Android 13 is critical, as API availability varies by version.\nThe large Android ecosystem effects how different devices may or may not uniformly adopt Android 13. This could impact functionality or appearance. Figure [1] illustrates the current distribution of Android 13 users, highlighting the importance of compatibility considerations.\n\n\n\n\n\n\nAdhering to regulations for handling Personally Identifiable Information (PII) is crucial due to the sensitive nature of data like salary details. While Android Room adds a layer of abstraction over SQLite, we will employ SQLCipher for full database encryption and additional field-level encryption for heightened security. Despite these precautions, we recognize that no encryption method is impervious to attacks.\n\n\n\n\n\nThe use of Android Room defines a SQLite database that resides on the users local device. Because the database is stored locally, an internet connection is not required. However, this relies on the user to have enough memory on their device to execute requests. Inadequate user memory will prevent the application’s ability to function correctly, relying on user awareness of their device’s storage capabilities to prevent execute all requests as intended.\n\n\n\n\n\nDesigning an application to be intuitive and responsive, but also adhere to accessibility guidelines often oppose one another. The design must comply with regulatory rules to comply with accessibility guidelines. This may limit design aspects such as contrast, color, bright images, etc. While Android provides accessibility hints, lack of access to a robust team to conduct usability testing will present a challenge to our four person group.\n\n\n\n\n\n\n\n\nAndroid Room will be used for database management.\nThe Room persistence library provides an abstraction layer over SQLite to allow fluent database access while harnessing the full power of SQLite. In particular, Room provides the following benefits:\n\nCompile-time verification of SQL queries.\nConvenience annotations that minimize repetitive and error-prone boilerplate code.\nStreamlined database migration paths\n\n\n\n\n\n\nThe application is designed for Android Operating System. Specifically, android 13 is the targeted system, and SDK 33 is the targeted SDK. Usability testing is conducted to ensure broad use and compatibility with the broader Android audience.\n\n\n\n\n\nThe Application is developed using Android Studios\nGradle 8.2 is used to compile, build, and package the application\nJava 17 is the primary programming language. However, the application contains XML, and Structured Query Language (SQL).\nA collaborative Git environment is used for version control, data integrity, and workflow management.\n\n\n\n\n\n\n\n\n\nFigure 2 represents the broad architectural structure for the Database class. The database class defines the database configuration and serves as the application’s main access point to the persisted data. The class is annotated with a @Database annotation that includes an entities array that lists all of the data entities associated with the database. The class must be an abstract class that extends the Database class. For each Data Access Object (DAO) class that is associated with the database, the database class must define an abstract method that has zero arguments and returns an instance of the DAO class.\nThe database will be responsible to store and retrieve all information about the users current job, job offers, and comparison settings\nTo visualize this, it’s helpful to think of data entities as objects within the Database Room. Entities in Room represent the app’s data structures, which are mapped to tables within the SQLite database. Each entity, annotated with @Entity, corresponds to a table where its fields represent columns. The @primaryKey specifies that the ‘id’ field as the primary key, and it will be automatically generated. These can be referenced later for specific purposes. @ColumnInfo is used to specify the name of the column in the database, ensuring our data model aligns with our database layout. For example, in our Job entity, fields like title, company, city, and state are mapped to respective columns, facilitating organized data storage and retrieval.\n@Entity\npublic class Job {\n    @PrimaryKey\n    public int uid;\n    \n    @ColumnInfo(title = \"title\")\n    public String title;\n\n    @ColumnInfo(company = \"company\")\n    public String company;\n\n    @ColumnInfo(city = \"city\")\n    public String city;\n     \n    @ColumnInfo(state = \"state\")\n    public String state;\n}\nThe DAO (Data Access Object) plays the role of abstracting the complexity of database access. Annotated with @Dao, it defines a set of methods for performing database operations, allowing to perform queries and manipulations. Methods within a DAO interface are annotated to represent specific SQL queries or transactions. In the code below, we use @Query for fetching data, @Insert for adding records, and @Delete for removing them. Each method performs interactions with the database. For example, our JobDao includes methods for retrieving job entries, inserting multiple jobs, and deleting a specific job.\n@Dao\npublic interface JobDao {\n    @Query(\"SELECT * FROM job\")\n    List&lt;Job&gt; getAll();\n\n    @Query(\"SELECT * FROM job WHERE title = :title AND company = :company\")\n    Job findByTitleAndCompany(String title, String company);\n\n    @Insert\n    void insertAll(Job... jobs);\n\n    @Delete\n    void delete(Job job);\n}\n\n\n\n\n\n\nTeamUMLDesign(11)\n\n\nThe component diagram depicted in figure 3 displays the structural relationships between the components in the application. Components are autonomous, encapsulated units within the application.\nThe Main Menu serves as the central hub from which users can navigate to various functionalities: Comparison Settings, Current Job Details, and Job Offers. Each of these functionalities is represented as a distinct component, reflecting their one-to-one relationship with the Main Menu. There is one condition which enable the user to access the comparison menu from the main menu. If the user already has entered a current job, and the user has entered at least one job offer, then they are able to navigate to the comparison menu.\nJob Offers component allows navigation to the Comparison Menu under two specific conditions: If the user has entered at least two job offers, or the user has entered one job offer and has entered a current job, the user may navigate to the comparison menu.\nThe Comparison Menu acts as a gateway to the Compare Job Offers component, which is accessible when the user has selected at least two jobs for comparison. It also provides options for the user to navigate back to the Main Menu or to the Job Offers component.\nIn the Compare Job Offers component, users can view selected job offers as a side-by-side comparison. From here, users can initiate a new comparison by returning to the Comparison Menu or choose to go back to the Main Menu.\n\n\n\n\n\n\nTeamUMLDesign(13)\n\n\nThis application is developed as a school project and not intended for immediate real-world deployment. However, understanding the deployment process will be important for future deployment. The deployment diagram depicted below illustrates the application’s packaging and installation process on any compatible Android device.\nThe diagram showcases three primary components that are packaged into the Application Package (.apk) file:\n\nCompiled Classes: These represent the compiled Java code that defines the application’s functionality.\nCompiled Resources: This includes all of the Android resources such as layouts, strings, and images.\nAndroidManifest.xml: The manifest file, which declares the application’s permissions, components, and minimum API/SDK requirements.\n\nThese components are compiled and packaged into an .apk file, which is the standard format for Android applications. When the application is installed on an Android device, the .apk is unpacked, and the manifest file guides the operating system in setting up the application’s execution environment.\nThe execution environment on the device is responsible for running the application. It interacts with the Android Room Database, which is created and managed locally on the device. This allows the application to store and retrieve data persistently, enabling functionalities such as saving job details and comparison settings directly on the user’s device without requiring an external database connection.\n\n\n\n\n\n\nOmmitted\n\n\n\n\n\n\n\nMobile wireframe(1)\n\n\nThe diagram in figure [ ] depicts the graphical user interface (GUI) design. From the main menu, the user can navigate to any of the five possible screens.\n\nThe Current Job GUI loads current job details if one exists. It also allows the user to input job details to be saved to the database.\nThe Comparison Settings GUI loads comparison settings if they exist, or it allows the user to input comparison settings.\nThe Enter Job Offer GUI allows the user to enter job offers. Selecting Compare with Current Job allows the user to navigate directly to the Job Comparison screen if the user has previously entered a current job.\nThe Comparison Menu allows user to view, delete, and compare jobs based on selected jobs via a checklist. Selecting the Compare launches the Job Comparison GUI.\nThe Job Comparison GUI allows the user to view the selected jobs as a side by side comparison. Selecting New Comparison will return the user to the Comparison menu.\nIf the user enters at least one job offer, and the user has a current job stored, then the user may select Compare Selected Jobs from the main menu. This will launch the Job Comparison GUI.\n\nThe figure above demonstrates the importance of the database as the main access point to persistent data. Every screen requires access the database to either store or retrieve data."
  },
  {
    "objectID": "DesignDocument.html#design-considerations",
    "href": "DesignDocument.html#design-considerations",
    "title": "Design Document",
    "section": "",
    "text": "The user should be able to enter and remove job details, job offers, adjust comparison settings, and compare jobs\nData that has been entered into the system is persisted, and is loaded after the application is opened back up.\nThe user will have sufficient hardware capabilities to handle the application’s performance requirements.\nAndroid Room provides a reliable method for the user to store data.\nStandard security practices will adequately protect user data from unauthorized access.\n\n\n\n\n\n\n\n\nThe application targets Android 13, introducing behavior changes and new APIs that may affect user experience. To ensure broad compatibility, testing across devices running Android 12 through Android 13 is critical, as API availability varies by version.\nThe large Android ecosystem effects how different devices may or may not uniformly adopt Android 13. This could impact functionality or appearance. Figure [1] illustrates the current distribution of Android 13 users, highlighting the importance of compatibility considerations.\n\n\n\n\n\n\nAdhering to regulations for handling Personally Identifiable Information (PII) is crucial due to the sensitive nature of data like salary details. While Android Room adds a layer of abstraction over SQLite, we will employ SQLCipher for full database encryption and additional field-level encryption for heightened security. Despite these precautions, we recognize that no encryption method is impervious to attacks.\n\n\n\n\n\nThe use of Android Room defines a SQLite database that resides on the users local device. Because the database is stored locally, an internet connection is not required. However, this relies on the user to have enough memory on their device to execute requests. Inadequate user memory will prevent the application’s ability to function correctly, relying on user awareness of their device’s storage capabilities to prevent execute all requests as intended.\n\n\n\n\n\nDesigning an application to be intuitive and responsive, but also adhere to accessibility guidelines often oppose one another. The design must comply with regulatory rules to comply with accessibility guidelines. This may limit design aspects such as contrast, color, bright images, etc. While Android provides accessibility hints, lack of access to a robust team to conduct usability testing will present a challenge to our four person group.\n\n\n\n\n\n\n\n\nAndroid Room will be used for database management.\nThe Room persistence library provides an abstraction layer over SQLite to allow fluent database access while harnessing the full power of SQLite. In particular, Room provides the following benefits:\n\nCompile-time verification of SQL queries.\nConvenience annotations that minimize repetitive and error-prone boilerplate code.\nStreamlined database migration paths\n\n\n\n\n\n\nThe application is designed for Android Operating System. Specifically, android 13 is the targeted system, and SDK 33 is the targeted SDK. Usability testing is conducted to ensure broad use and compatibility with the broader Android audience.\n\n\n\n\n\nThe Application is developed using Android Studios\nGradle 8.2 is used to compile, build, and package the application\nJava 17 is the primary programming language. However, the application contains XML, and Structured Query Language (SQL).\nA collaborative Git environment is used for version control, data integrity, and workflow management."
  },
  {
    "objectID": "DesignDocument.html#architectural-design",
    "href": "DesignDocument.html#architectural-design",
    "title": "Design Document",
    "section": "",
    "text": "Figure 2 represents the broad architectural structure for the Database class. The database class defines the database configuration and serves as the application’s main access point to the persisted data. The class is annotated with a @Database annotation that includes an entities array that lists all of the data entities associated with the database. The class must be an abstract class that extends the Database class. For each Data Access Object (DAO) class that is associated with the database, the database class must define an abstract method that has zero arguments and returns an instance of the DAO class.\nThe database will be responsible to store and retrieve all information about the users current job, job offers, and comparison settings\nTo visualize this, it’s helpful to think of data entities as objects within the Database Room. Entities in Room represent the app’s data structures, which are mapped to tables within the SQLite database. Each entity, annotated with @Entity, corresponds to a table where its fields represent columns. The @primaryKey specifies that the ‘id’ field as the primary key, and it will be automatically generated. These can be referenced later for specific purposes. @ColumnInfo is used to specify the name of the column in the database, ensuring our data model aligns with our database layout. For example, in our Job entity, fields like title, company, city, and state are mapped to respective columns, facilitating organized data storage and retrieval.\n@Entity\npublic class Job {\n    @PrimaryKey\n    public int uid;\n    \n    @ColumnInfo(title = \"title\")\n    public String title;\n\n    @ColumnInfo(company = \"company\")\n    public String company;\n\n    @ColumnInfo(city = \"city\")\n    public String city;\n     \n    @ColumnInfo(state = \"state\")\n    public String state;\n}\nThe DAO (Data Access Object) plays the role of abstracting the complexity of database access. Annotated with @Dao, it defines a set of methods for performing database operations, allowing to perform queries and manipulations. Methods within a DAO interface are annotated to represent specific SQL queries or transactions. In the code below, we use @Query for fetching data, @Insert for adding records, and @Delete for removing them. Each method performs interactions with the database. For example, our JobDao includes methods for retrieving job entries, inserting multiple jobs, and deleting a specific job.\n@Dao\npublic interface JobDao {\n    @Query(\"SELECT * FROM job\")\n    List&lt;Job&gt; getAll();\n\n    @Query(\"SELECT * FROM job WHERE title = :title AND company = :company\")\n    Job findByTitleAndCompany(String title, String company);\n\n    @Insert\n    void insertAll(Job... jobs);\n\n    @Delete\n    void delete(Job job);\n}\n\n\n\n\n\n\nTeamUMLDesign(11)\n\n\nThe component diagram depicted in figure 3 displays the structural relationships between the components in the application. Components are autonomous, encapsulated units within the application.\nThe Main Menu serves as the central hub from which users can navigate to various functionalities: Comparison Settings, Current Job Details, and Job Offers. Each of these functionalities is represented as a distinct component, reflecting their one-to-one relationship with the Main Menu. There is one condition which enable the user to access the comparison menu from the main menu. If the user already has entered a current job, and the user has entered at least one job offer, then they are able to navigate to the comparison menu.\nJob Offers component allows navigation to the Comparison Menu under two specific conditions: If the user has entered at least two job offers, or the user has entered one job offer and has entered a current job, the user may navigate to the comparison menu.\nThe Comparison Menu acts as a gateway to the Compare Job Offers component, which is accessible when the user has selected at least two jobs for comparison. It also provides options for the user to navigate back to the Main Menu or to the Job Offers component.\nIn the Compare Job Offers component, users can view selected job offers as a side-by-side comparison. From here, users can initiate a new comparison by returning to the Comparison Menu or choose to go back to the Main Menu.\n\n\n\n\n\n\nTeamUMLDesign(13)\n\n\nThis application is developed as a school project and not intended for immediate real-world deployment. However, understanding the deployment process will be important for future deployment. The deployment diagram depicted below illustrates the application’s packaging and installation process on any compatible Android device.\nThe diagram showcases three primary components that are packaged into the Application Package (.apk) file:\n\nCompiled Classes: These represent the compiled Java code that defines the application’s functionality.\nCompiled Resources: This includes all of the Android resources such as layouts, strings, and images.\nAndroidManifest.xml: The manifest file, which declares the application’s permissions, components, and minimum API/SDK requirements.\n\nThese components are compiled and packaged into an .apk file, which is the standard format for Android applications. When the application is installed on an Android device, the .apk is unpacked, and the manifest file guides the operating system in setting up the application’s execution environment.\nThe execution environment on the device is responsible for running the application. It interacts with the Android Room Database, which is created and managed locally on the device. This allows the application to store and retrieve data persistently, enabling functionalities such as saving job details and comparison settings directly on the user’s device without requiring an external database connection."
  },
  {
    "objectID": "DesignDocument.html#low-level-design",
    "href": "DesignDocument.html#low-level-design",
    "title": "Design Document",
    "section": "",
    "text": "Ommitted"
  },
  {
    "objectID": "DesignDocument.html#user-interface-design",
    "href": "DesignDocument.html#user-interface-design",
    "title": "Design Document",
    "section": "",
    "text": "Mobile wireframe(1)\n\n\nThe diagram in figure [ ] depicts the graphical user interface (GUI) design. From the main menu, the user can navigate to any of the five possible screens.\n\nThe Current Job GUI loads current job details if one exists. It also allows the user to input job details to be saved to the database.\nThe Comparison Settings GUI loads comparison settings if they exist, or it allows the user to input comparison settings.\nThe Enter Job Offer GUI allows the user to enter job offers. Selecting Compare with Current Job allows the user to navigate directly to the Job Comparison screen if the user has previously entered a current job.\nThe Comparison Menu allows user to view, delete, and compare jobs based on selected jobs via a checklist. Selecting the Compare launches the Job Comparison GUI.\nThe Job Comparison GUI allows the user to view the selected jobs as a side by side comparison. Selecting New Comparison will return the user to the Comparison menu.\nIf the user enters at least one job offer, and the user has a current job stored, then the user may select Compare Selected Jobs from the main menu. This will launch the Job Comparison GUI.\n\nThe figure above demonstrates the importance of the database as the main access point to persistent data. Every screen requires access the database to either store or retrieve data."
  },
  {
    "objectID": "GreenCollectivesReadMe.html",
    "href": "GreenCollectivesReadMe.html",
    "title": "Green Collectives",
    "section": "",
    "text": "A Desktop Application built with javaFx with the intention of solving relevant problems and inefficiencies that U.S. Army Service members, and gun enthusiasts face on a daily basis.\n\n\nAfter 10+ years in the military, I’m well acquatinted with it’s inefficiencies. I wanted to build something to help military personnel with some of their most relevant issues. Green Collectives is a “one-stop-shop” meant to provide soldiers with access to useful files, a consolidated list of military websites, tools to build and manage shooting ranges, competitive workouts, and access to current events.\nThe application’s features are as follows:\n\n\n\nThe resources feature has 19 links that load different resource drives. The drives act as file repositories for files that are available for download by utilizing client-initiated GET requests through an HTTP API, which is then routed to a Lambda function in AWS, programmed in Node.js on the backend. This Lambda function generates pre-signed URLs, enabling users to execute their requests. These requests are then directed to an AWS S3 bucket within an encrypted folder. There is also a link to a web application that I built as well that does the same tasks, but it allows you to upload files to contribute as well. It’s important to note that all files are unclassified and are free of PII.\n\n \n\n\n\n\nThe Links feature compiles every useful military website, selected on their value to the military community. A few of the links require military issued hardware to access.\n\n\n\n\n\n\nThe Range Builder feature grants access to over to 130+ pistol and rifle drills. Users can use the checkbox to build their desired shooting range. The user can also “preview” each drill to see a detailed list of instructions for each drill, as well as an embedded youtube video. When finished, they select “Build My Range”.\n\n \n\nUsers are then prompted to a screen where they can enter amplifying information (number of shooters and iterations per shooter). The user can then click “calculate ammo expenditure” to view their estimated ammunition expenditure for their custom range day. They can then use the Apache pdfbox Library to save to their local device as a pdf.\n\n\n\nAmmo Expenditure\n\n\n\n\n\nEach drill corresponds to a number of estimated rounds expended (per drill) through the use of a list, which is inserted into a hashmap, and passed into another Class through use of a constructor when a new scene is loaded. The end result is a list that can be used in a simple algorithm to calculate ammunition expenditure for any amount of drills.\n\n\n\nThe Workouts Feature is a fun take on mortal combat with some of my Green Beret Buddies as substitutes. The user can cycle through a list of Green Berets, and download workouts. When the user downloads a workout, they are inplimenting the same process as before when requesting to download files from the resources page by making GET requests through an HTTP API – routed to a Lambda function in AWS, programmed in Node.js on the backend. This Lambda function generates pre-signed URLs, enabling users to execute their requests. These requests are then directed to an AWS S3 bucket within an encrypted folder.\n\n\n\nWorkouts\n\n\n\n\n\nThe News Feature utilizes the Java Rome Library, and makes RSS feed requests to several news outlets – The Hill, Newsweek, Rand National Terroism articles, Rand Cyber and Data Science articles, Rand Homeland Security and Public Safety articles, The Army Times, Atlas News, and the White House Briefing room.\n\n \n\n\n\n\n\n\n- org.apache.pdfbox:pdfbox:2.0.29\n- ch.qos.logback:logback-classic:1.4.11\n- org.slf4j:slf4j-api:2.0.6\n- org.apache.httpcomponents:httpclient:4.5.14\n- org.apache.pdfbox:fontbox:2.0.29\n- org.openjfx:javafx-web:20\n- com.rometools:rome:2.1.0\n- org.apache.pdfbox:pdfbox-tools:2.0.29\n- org.apache.pdfbox:xmpbox:2.0.29\n- com.gluonhq:ignite-common:1.2.2\n- org.openjfx:javafx-controls:20\n- org.openjfx:javafx-fxml:20\n- org.controlsfx:controlsfx:11.1.2\n- org.kordamp.bootstrapfx:bootstrapfx-core:0.4.0\n- org.junit.jupiter:junit-jupiter-api:5.9.2 (with a 'test' scope)\n- org.junit.jupiter:junit-jupiter-engine:5.9.2 (with a 'test' scope)\n- com.vaadin.external.google:android-json:0.0.20131108.vaadin1\nFor a complete list of dependencies and their versions, please refer to the pom.xml file.\n\n\n\nYou can download the latest version of our application for the following platforms:\n\n\n\n\nWindows Installer (.msi)\n\n\n\n\nEasiest Way:  \n\nLinux (Debian-based) (.deb)\n\nTerminal commands to install after download:\ncd Downloads\nsudo dpkg -i greencollectives_1.0_amd64.deb\n\n\n\n\nmacOS (AArch64 architecture) (.dmg)\n\n\n\n\n\nTyler Dickson Email Me\n\n\n\nThis project is licensed under the GNU GENERAL PUBLIC LICENSE VERSION 3"
  },
  {
    "objectID": "GreenCollectivesReadMe.html#description",
    "href": "GreenCollectivesReadMe.html#description",
    "title": "Green Collectives",
    "section": "",
    "text": "After 10+ years in the military, I’m well acquatinted with it’s inefficiencies. I wanted to build something to help military personnel with some of their most relevant issues. Green Collectives is a “one-stop-shop” meant to provide soldiers with access to useful files, a consolidated list of military websites, tools to build and manage shooting ranges, competitive workouts, and access to current events.\nThe application’s features are as follows:"
  },
  {
    "objectID": "GreenCollectivesReadMe.html#resources",
    "href": "GreenCollectivesReadMe.html#resources",
    "title": "Green Collectives",
    "section": "",
    "text": "The resources feature has 19 links that load different resource drives. The drives act as file repositories for files that are available for download by utilizing client-initiated GET requests through an HTTP API, which is then routed to a Lambda function in AWS, programmed in Node.js on the backend. This Lambda function generates pre-signed URLs, enabling users to execute their requests. These requests are then directed to an AWS S3 bucket within an encrypted folder. There is also a link to a web application that I built as well that does the same tasks, but it allows you to upload files to contribute as well. It’s important to note that all files are unclassified and are free of PII."
  },
  {
    "objectID": "GreenCollectivesReadMe.html#links",
    "href": "GreenCollectivesReadMe.html#links",
    "title": "Green Collectives",
    "section": "",
    "text": "The Links feature compiles every useful military website, selected on their value to the military community. A few of the links require military issued hardware to access."
  },
  {
    "objectID": "GreenCollectivesReadMe.html#range-builder",
    "href": "GreenCollectivesReadMe.html#range-builder",
    "title": "Green Collectives",
    "section": "",
    "text": "The Range Builder feature grants access to over to 130+ pistol and rifle drills. Users can use the checkbox to build their desired shooting range. The user can also “preview” each drill to see a detailed list of instructions for each drill, as well as an embedded youtube video. When finished, they select “Build My Range”.\n\n \n\nUsers are then prompted to a screen where they can enter amplifying information (number of shooters and iterations per shooter). The user can then click “calculate ammo expenditure” to view their estimated ammunition expenditure for their custom range day. They can then use the Apache pdfbox Library to save to their local device as a pdf.\n\n\n\nAmmo Expenditure\n\n\n\n\n\nEach drill corresponds to a number of estimated rounds expended (per drill) through the use of a list, which is inserted into a hashmap, and passed into another Class through use of a constructor when a new scene is loaded. The end result is a list that can be used in a simple algorithm to calculate ammunition expenditure for any amount of drills."
  },
  {
    "objectID": "GreenCollectivesReadMe.html#workouts",
    "href": "GreenCollectivesReadMe.html#workouts",
    "title": "Green Collectives",
    "section": "",
    "text": "The Workouts Feature is a fun take on mortal combat with some of my Green Beret Buddies as substitutes. The user can cycle through a list of Green Berets, and download workouts. When the user downloads a workout, they are inplimenting the same process as before when requesting to download files from the resources page by making GET requests through an HTTP API – routed to a Lambda function in AWS, programmed in Node.js on the backend. This Lambda function generates pre-signed URLs, enabling users to execute their requests. These requests are then directed to an AWS S3 bucket within an encrypted folder.\n\n\n\nWorkouts"
  },
  {
    "objectID": "GreenCollectivesReadMe.html#news",
    "href": "GreenCollectivesReadMe.html#news",
    "title": "Green Collectives",
    "section": "",
    "text": "The News Feature utilizes the Java Rome Library, and makes RSS feed requests to several news outlets – The Hill, Newsweek, Rand National Terroism articles, Rand Cyber and Data Science articles, Rand Homeland Security and Public Safety articles, The Army Times, Atlas News, and the White House Briefing room."
  },
  {
    "objectID": "GreenCollectivesReadMe.html#getting-started",
    "href": "GreenCollectivesReadMe.html#getting-started",
    "title": "Green Collectives",
    "section": "",
    "text": "- org.apache.pdfbox:pdfbox:2.0.29\n- ch.qos.logback:logback-classic:1.4.11\n- org.slf4j:slf4j-api:2.0.6\n- org.apache.httpcomponents:httpclient:4.5.14\n- org.apache.pdfbox:fontbox:2.0.29\n- org.openjfx:javafx-web:20\n- com.rometools:rome:2.1.0\n- org.apache.pdfbox:pdfbox-tools:2.0.29\n- org.apache.pdfbox:xmpbox:2.0.29\n- com.gluonhq:ignite-common:1.2.2\n- org.openjfx:javafx-controls:20\n- org.openjfx:javafx-fxml:20\n- org.controlsfx:controlsfx:11.1.2\n- org.kordamp.bootstrapfx:bootstrapfx-core:0.4.0\n- org.junit.jupiter:junit-jupiter-api:5.9.2 (with a 'test' scope)\n- org.junit.jupiter:junit-jupiter-engine:5.9.2 (with a 'test' scope)\n- com.vaadin.external.google:android-json:0.0.20131108.vaadin1\nFor a complete list of dependencies and their versions, please refer to the pom.xml file.\n\n\n\nYou can download the latest version of our application for the following platforms:\n\n\n\n\nWindows Installer (.msi)\n\n\n\n\nEasiest Way:  \n\nLinux (Debian-based) (.deb)\n\nTerminal commands to install after download:\ncd Downloads\nsudo dpkg -i greencollectives_1.0_amd64.deb\n\n\n\n\nmacOS (AArch64 architecture) (.dmg)"
  },
  {
    "objectID": "GreenCollectivesReadMe.html#author",
    "href": "GreenCollectivesReadMe.html#author",
    "title": "Green Collectives",
    "section": "",
    "text": "Tyler Dickson Email Me"
  },
  {
    "objectID": "GreenCollectivesReadMe.html#license",
    "href": "GreenCollectivesReadMe.html#license",
    "title": "Green Collectives",
    "section": "",
    "text": "This project is licensed under the GNU GENERAL PUBLIC LICENSE VERSION 3"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tyler Dickson",
    "section": "",
    "text": "Hey there, I’m Tyler Dickson, a former Green Beret who found his way into the world of software development. While I initially pursued/obtained a degree in Financial Economics at West Point Military Academy, a few years ago, I stumbled upon my love for coding. These days, you’ll often find me immersed in academic pursuits, as I recently kicked off a Master’s Program in Computer Science at Georgia Tech.\nBecause of my deep ties to the military, I’ve always had a strong desire to support fellow servicemen and women. During my time as a Green Beret, I had the privilege of assuming leadership roles in some of the world’s most politically sensitive and complex regions, spanning from the Middle East to Eastern Europe. This is what drove me to create an all-in-one solution—an application designed to furnish soldiers with convenient access to essential files, a comprehensive directory of military websites, resources for constructing and overseeing shooting ranges, engaging workout routines, and real-time updates on current events.\nYou can check out the application from the Snap store here:\n \nCheck out the Github Repo here.\nIf you prefer a high level overview of the project, check out the README File.\nAnother fun project I recently completed is the creation of a web application aimed at addressing a critical challenge faced by soldiers every day – the accessibility of essential files. Just as sites like Github have made it easy for tech folks to share files, I’ve built a collaborative file sharing platform where soldiers can upload and share helpful files. The site is structured around an HTTP API gateway that send requests to a node js lambda function in AWS to generate pre signed urls, and making GET and PUT requests to an S3 Bucket. Click here to see the site.\nFinally, a copy of my CV can be downloaded here."
  },
  {
    "objectID": "projectPage.html",
    "href": "projectPage.html",
    "title": "Projects",
    "section": "",
    "text": "A Desktop Application built with javaFx with the intention of solving relevant problems and inefficiencies that U.S. Army Service members, and gun enthusiasts face on a daily basis\nLink\n\n\n\nA collaborative file sharing platform where soldiers can upload and share helpful files.\nLink\n\n\n\nA job comparison application built in Android Studios using Android Room.\nHigh Level Overview\n\n\n\nA C++ program that takes a series of logical connectives as user input and displays a truth table as binary output.\nLogical connectives are pivotal operators that amalgamate or modify logical statements to construct intricate propositions, enabling the articulation of relationships among these statements. These are indispensable in building logical expressions and in analytical reasoning. Truth tables are essential tools in visualizing and resolving logical dilemmas, engaging in Boolean algebra, assessing logical equivalence, and facilitating decision-making processes. Boolean operations underpin many everyday functionalities, including search engine queries.\nUsers input a sequence of logical connectives, and the program renders these inputs either as truth tables or as logic circuit diagrams. A suite of algorithms will parse and iterate over characters, variables, and constants to produce the desired outputs.\nHigh Level Overview\nCheck out the Github Repo here.\n\n\n\nA research paper culminating in the development of a medium fidelity prototype focusing on the redesign of PowerSchool’s Individualized Education Programs (IEPs) interface, particularly the Present Level of Performance (PLOP) interface.\nLink"
  },
  {
    "objectID": "projectPage.html#green-collectives---desktop-application",
    "href": "projectPage.html#green-collectives---desktop-application",
    "title": "Projects",
    "section": "",
    "text": "A Desktop Application built with javaFx with the intention of solving relevant problems and inefficiencies that U.S. Army Service members, and gun enthusiasts face on a daily basis\nLink"
  },
  {
    "objectID": "projectPage.html#green-collectives---web-application",
    "href": "projectPage.html#green-collectives---web-application",
    "title": "Projects",
    "section": "",
    "text": "A collaborative file sharing platform where soldiers can upload and share helpful files.\nLink"
  },
  {
    "objectID": "projectPage.html#android-job-comparison-application",
    "href": "projectPage.html#android-job-comparison-application",
    "title": "Projects",
    "section": "",
    "text": "A job comparison application built in Android Studios using Android Room.\nHigh Level Overview"
  },
  {
    "objectID": "projectPage.html#propositional-logic-logic-circuit-calculator",
    "href": "projectPage.html#propositional-logic-logic-circuit-calculator",
    "title": "Projects",
    "section": "",
    "text": "A C++ program that takes a series of logical connectives as user input and displays a truth table as binary output.\nLogical connectives are pivotal operators that amalgamate or modify logical statements to construct intricate propositions, enabling the articulation of relationships among these statements. These are indispensable in building logical expressions and in analytical reasoning. Truth tables are essential tools in visualizing and resolving logical dilemmas, engaging in Boolean algebra, assessing logical equivalence, and facilitating decision-making processes. Boolean operations underpin many everyday functionalities, including search engine queries.\nUsers input a sequence of logical connectives, and the program renders these inputs either as truth tables or as logic circuit diagrams. A suite of algorithms will parse and iterate over characters, variables, and constants to produce the desired outputs.\nHigh Level Overview\nCheck out the Github Repo here."
  },
  {
    "objectID": "projectPage.html#re-imagining-data-collection-and-analysis-in-special-education",
    "href": "projectPage.html#re-imagining-data-collection-and-analysis-in-special-education",
    "title": "Projects",
    "section": "",
    "text": "A research paper culminating in the development of a medium fidelity prototype focusing on the redesign of PowerSchool’s Individualized Education Programs (IEPs) interface, particularly the Present Level of Performance (PLOP) interface.\nLink"
  }
]